{
  "hash": "1c0dd4f1e218471236a4b5c34801510c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Scaling variables in R\"\nauthor: \"Matthew J. Kmiecik\"\ndate: \"03 June 2025\"\ndescription: \"A walkthrough of a tip I recently learned\"\ncategories:\n  - R\n  - statistics\nexecute:\n  warning: false\n  message: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\nHerein I present a walkthrough of a recent improvement I made to my analyses when scaling (i.e., normalizing) variables is important. \n\nScaling or normalizing variables in R is super convenient by using the `scale(..., center = TRUE, scale = TRUE)` function and default arguments. Here, the variable `x` is mean centered and scaled to unit variance, also called a z-score.\n\nLet's do this on the `mtcars` dataset variable `hp`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mtcars)\nmtcars$hp_z <- scale(mtcars$hp)\n```\n:::\n\n\n\nHere's proof that the newly scaled `hp_z` variable was indeed scaled:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nmtcars %>% \n  summarise(across(contains(\"hp\"), list(mean = mean, sd = sd))) %>%\n  round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  hp_mean hp_sd hp_z_mean hp_z_sd\n1  146.69 68.56         0       1\n```\n\n\n:::\n:::\n\n\n\nAs we can see, the _M_=0 and _Standard Deviation(SD)_=1 for `hp_z`.\n\nThe `scale()` function, however, does something really useful that I used to ignore for the longest time; it saves the scaling factors as attributes in the column/variable. This is seen in a few ways: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mtcars$hp_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars$hp_z\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             [,1]\n [1,] -0.53509284\n [2,] -0.53509284\n [3,] -0.78304046\n [4,] -0.53509284\n [5,]  0.41294217\n [6,] -0.60801861\n [7,]  1.43390296\n [8,] -1.23518023\n [9,] -0.75387015\n[10,] -0.34548584\n[11,] -0.34548584\n[12,]  0.48586794\n[13,]  0.48586794\n[14,]  0.48586794\n[15,]  0.85049680\n[16,]  0.99634834\n[17,]  1.21512565\n[18,] -1.17683962\n[19,] -1.38103178\n[20,] -1.19142477\n[21,] -0.72469984\n[22,]  0.04831332\n[23,]  0.04831332\n[24,]  1.43390296\n[25,]  0.41294217\n[26,] -1.17683962\n[27,] -0.81221077\n[28,] -0.49133738\n[29,]  1.71102089\n[30,]  0.41294217\n[31,]  2.74656682\n[32,] -0.54967799\nattr(,\"scaled:center\")\n[1] 146.6875\nattr(,\"scaled:scale\")\n[1] 68.56287\n```\n\n\n:::\n:::\n\n\n\nThe attribute for the mean-centering (i.e., the mean) can be accessed like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(mtcars$hp_z, \"scaled:center\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 146.6875\n```\n\n\n:::\n:::\n\n\n\nAnd the attribute for the scaling factor (i.e., the _SD_) can be accessed like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(mtcars$hp_z, \"scaled:center\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 146.6875\n```\n\n\n:::\n:::\n\n\n\nIn sum, the output of `scale()` is a `\"matrix\" \"array\"` with the centering and scaling factors, if requested, attached as attributes. Notice how they match the _M_ and _SD_ of the original `mtcars$hp` variable above.\n\nHowever, there are a few issues with using `scale()`. The `\"matrix\" \"array\"` output is little annoying because it prints differently: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(mtcars, rownames = \"car\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 13\n   car           mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <chr>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n# ℹ 1 more variable: hp_z <dbl[,1]>\n```\n\n\n:::\n:::\n\n\n\nand it does not play nicely with `predict()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(mpg ~ 1 + hp_z, data = mtcars)\nnew_data <- data.frame(hp_z = seq(-2, 2, length.out = 100))\npredict(mod, newdata = new_data, type = \"response\", se.fit = TRUE)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: variable 'hp_z' was fitted with type \"nmatrix.1\" but type \"numeric\" was supplied\n```\n\n\n:::\n:::\n\n\n\nIn the past, I would normally strip these features by wrapping the call with `as.numeric()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$hp_zn <- as.numeric(scale(mtcars$hp))\n```\n:::\n\n\n\nAlthough this will work, you lose the awesome feature of having access to the centering/scaling attributes.\n\nI found a nice elegant solution to this issue via this Stack Overflow [post](https://stackoverflow.com/questions/66534641/getting-persistent-error-when-trying-to-predict-new-data-from-a-glm-in-r)! The `drop()` function will drop the formatting of `scale()` without the loss of attributes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$hp_z <- drop(scale(mtcars$hp)) # using drop\nclass(mtcars$hp_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas_tibble(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 13\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb   hp_z\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 -0.535\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 -0.535\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 -0.783\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 -0.535\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2  0.413\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 -0.608\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4  1.43 \n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2 -1.24 \n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 -0.754\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 -0.345\n# ℹ 22 more rows\n# ℹ 1 more variable: hp_zn <dbl>\n```\n\n\n:::\n:::\n\n\n\nUsing `drop()` no longer causes an issue with `predict()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(mpg ~ 1 + hp_z, data = mtcars)\nnew_data <- data.frame(hp_z = seq(-2, 2, length.out = 100))\npred <- predict(mod, newdata = new_data, type = \"response\", se.fit = TRUE)\nnew_data <- cbind(new_data, pred)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# plots\nggplot(new_data, aes(hp_z, fit)) + \n  geom_line () +\n  geom_ribbon(aes(ymin = fit-se.fit, ymax = fit+se.fit), alpha = 1/3) +\n  labs(x = \"HP (in SD units)\", y = \"Predicted MPG\", caption = \"SE shading.\") +\n  scale_x_continuous(breaks = seq(-2, 2, .5)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](post-labeller_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\nBut what if we want to represent the x-axis in its original units? No problem, just use the attributes from the scaled column to convert back to the original unstandardized units:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- attr(mtcars$hp_z, \"scaled:center\")\nsd <- attr(mtcars$hp_z, \"scaled:scale\")\nnew_data$hp_o <- new_data$hp_z * sd + m\n\n# plots\nggplot(new_data, aes(hp_o, fit)) + \n  geom_line () +\n  geom_ribbon(aes(ymin = fit-se.fit, ymax = fit+se.fit), alpha = 1/3) +\n  labs(x = \"HP (in SD units)\", y = \"Predicted MPG\", caption = \"SE shading.\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](post-labeller_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nThank you `drop()`!\n\n## Summary\n\nWhen scaling variables in R via `scale()`, be sure to use the `drop()` function to strip away the dimensions of `scale()`'s output. This new variable/column will play nicely with `predict()` and retain the center and scale attributes for later use.\n\n<br >\n\n<div style=\"text-align: center;\">\n  <iframe src=\"https://mattkmiecik.substack.com/embed\" width=\"480\" height=\"320\" style=\"border:1px solid #EEE; background:white;\" frameborder=\"0\" scrolling=\"no\"></iframe>\n</div>",
    "supporting": [
      "post-labeller_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}