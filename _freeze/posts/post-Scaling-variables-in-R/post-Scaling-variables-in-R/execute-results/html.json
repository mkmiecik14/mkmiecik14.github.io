{
  "hash": "ada53d4a8bae30523a649f9da1f70f4f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Scaling variables in R\"\nauthor: \"Matthew J. Kmiecik\"\ndate: \"03 June 2025\"\ndescription: \"A walkthrough of a tip I recently learned\"\ncategories:\n  - R\n  - statistics\nexecute:\n  warning: false\n  message: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\nHerein I present a walkthrough of a recent improvement I made to my analyses when scaling (i.e., normalizing) variables. \n\nScaling or normalizing variables in R is super convenient by using the `scale(x, center = TRUE, scale = TRUE)` function and default arguments. Here, the variable `x` is mean centered and scaled to unit variance, also called a Z-score.\n\nLet's do this on the `mtcars` dataset variable `hp`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mtcars)\nmtcars$hp_z <- scale(mtcars$hp)\n```\n:::\n\n\n\nHere's proof that the newly scaled `hp_z` variable was indeed scaled:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nmtcars %>% \n  summarise(across(contains(\"hp\"), list(mean = mean, sd = sd))) %>%\n  round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  hp_mean hp_sd hp_z_mean hp_z_sd\n1  146.69 68.56         0       1\n```\n\n\n:::\n:::\n\n\n\nAs we can see, the _M_=0 and _Standard Deviation(SD)_=1 for `hp_z`.\n\nThe `scale()` function, however, does something really useful that I used to ignore for the longest time; it saves the scaling factors as attributes in the column/variable. This is seen in a few ways: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mtcars$hp_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars$hp_z\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             [,1]\n [1,] -0.53509284\n [2,] -0.53509284\n [3,] -0.78304046\n [4,] -0.53509284\n [5,]  0.41294217\n [6,] -0.60801861\n [7,]  1.43390296\n [8,] -1.23518023\n [9,] -0.75387015\n[10,] -0.34548584\n[11,] -0.34548584\n[12,]  0.48586794\n[13,]  0.48586794\n[14,]  0.48586794\n[15,]  0.85049680\n[16,]  0.99634834\n[17,]  1.21512565\n[18,] -1.17683962\n[19,] -1.38103178\n[20,] -1.19142477\n[21,] -0.72469984\n[22,]  0.04831332\n[23,]  0.04831332\n[24,]  1.43390296\n[25,]  0.41294217\n[26,] -1.17683962\n[27,] -0.81221077\n[28,] -0.49133738\n[29,]  1.71102089\n[30,]  0.41294217\n[31,]  2.74656682\n[32,] -0.54967799\nattr(,\"scaled:center\")\n[1] 146.6875\nattr(,\"scaled:scale\")\n[1] 68.56287\n```\n\n\n:::\n:::\n\n\n\nThe attribute for the mean-centering (i.e., the mean) can be accessed like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(mtcars$hp_z, \"scaled:center\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 146.6875\n```\n\n\n:::\n:::\n\n\n\nAnd the attribute for the scaling factor (i.e., the _SD_) can be accessed like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(mtcars$hp_z, \"scaled:scale\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.56287\n```\n\n\n:::\n:::\n\n\n\nIn sum, the output of `scale()` is a `\"matrix\" \"array\"` with the centering and scaling factors, if requested, attached as attributes. Notice how they match the _M_ and _SD_ of the original `mtcars$hp` variable above.\n\n## The problem\n\nHowever, there are a few issues with using `scale()`. The `\"matrix\" \"array\"` output is little annoying because it prints differently: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(select(mtcars, mpg, contains(\"hp\")), rownames = \"car\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 4\n   car                 mpg    hp hp_z[,1]\n   <chr>             <dbl> <dbl>    <dbl>\n 1 Mazda RX4          21     110   -0.535\n 2 Mazda RX4 Wag      21     110   -0.535\n 3 Datsun 710         22.8    93   -0.783\n 4 Hornet 4 Drive     21.4   110   -0.535\n 5 Hornet Sportabout  18.7   175    0.413\n 6 Valiant            18.1   105   -0.608\n 7 Duster 360         14.3   245    1.43 \n 8 Merc 240D          24.4    62   -1.24 \n 9 Merc 230           22.8    95   -0.754\n10 Merc 280           19.2   123   -0.345\n# ℹ 22 more rows\n```\n\n\n:::\n:::\n\n\n\nand it does not play nicely with `predict()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(mpg ~ 1 + hp_z, data = mtcars)\nnew_data <- data.frame(hp_z = seq(-2, 2, length.out = 100))\npredict(mod, newdata = new_data, type = \"response\", se.fit = TRUE)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: variable 'hp_z' was fitted with type \"nmatrix.1\" but type \"numeric\" was supplied\n```\n\n\n:::\n:::\n\n\n\nIn the past, I would normally strip these features by wrapping the call with `as.numeric()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$hp_zn <- as.numeric(scale(mtcars$hp))\n```\n:::\n\n\n\nAlthough this will work, you lose the awesome feature of having access to the centering/scaling attributes.\n\n## The solution\n\nI found a nice elegant solution to this issue via this Stack Overflow [post](https://stackoverflow.com/questions/66534641/getting-persistent-error-when-trying-to-predict-new-data-from-a-glm-in-r).\n\nThe `drop()` function will drop the formatting of `scale()` without the loss of attributes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$hp_z <- drop(scale(mtcars$hp)) # using drop\nclass(mtcars$hp_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas_tibble(select(mtcars, mpg, contains(\"hp\")), rownames = \"car\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 5\n   car                 mpg    hp   hp_z  hp_zn\n   <chr>             <dbl> <dbl>  <dbl>  <dbl>\n 1 Mazda RX4          21     110 -0.535 -0.535\n 2 Mazda RX4 Wag      21     110 -0.535 -0.535\n 3 Datsun 710         22.8    93 -0.783 -0.783\n 4 Hornet 4 Drive     21.4   110 -0.535 -0.535\n 5 Hornet Sportabout  18.7   175  0.413  0.413\n 6 Valiant            18.1   105 -0.608 -0.608\n 7 Duster 360         14.3   245  1.43   1.43 \n 8 Merc 240D          24.4    62 -1.24  -1.24 \n 9 Merc 230           22.8    95 -0.754 -0.754\n10 Merc 280           19.2   123 -0.345 -0.345\n# ℹ 22 more rows\n```\n\n\n:::\n:::\n\n\n\nUsing `drop()` no longer causes an issue with `predict()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(mpg ~ 1 + hp_z, data = mtcars)\nnew_data <- data.frame(hp_z = seq(-2, 2, length.out = 100))\npred <- predict(mod, newdata = new_data, type = \"response\", se.fit = TRUE)\nnew_data <- cbind(new_data, pred)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# plots\nggplot(new_data, aes(hp_z, fit)) + \n  geom_line () +\n  geom_ribbon(aes(ymin = fit-se.fit, ymax = fit+se.fit), alpha = 1/3) +\n  labs(x = \"HP (in SD units)\", y = \"Predicted MPG\", caption = \"SE shading.\") +\n  scale_x_continuous(breaks = seq(-2, 2, .5)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](post-Scaling-variables-in-R_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\nBut what if we want to represent the x-axis in its original units? No problem! Just use the attributes from the scaled column to convert back to the original unstandardized units:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- attr(mtcars$hp_z, \"scaled:center\")\nsd <- attr(mtcars$hp_z, \"scaled:scale\")\nnew_data$hp_o <- new_data$hp_z * sd + m\n\n# plots\nggplot(new_data, aes(hp_o, fit)) + \n  geom_line () +\n  geom_ribbon(aes(ymin = fit-se.fit, ymax = fit+se.fit), alpha = 1/3) +\n  labs(x = \"HP (in original units)\", y = \"Predicted MPG\", caption = \"SE shading.\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](post-Scaling-variables-in-R_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nThank you `drop()`!\n\n## Summary\n\nWhen scaling variables in R via `scale()`, be sure to use the `drop()` function to strip away the dimensions of `scale()`'s output. This new variable/column will play nicely with `predict()` and retain the center and scale attributes for later use.\n\n<br >\n\n<div style=\"text-align: center;\">\n  <iframe src=\"https://mattkmiecik.substack.com/embed\" width=\"480\" height=\"320\" style=\"border:1px solid #EEE; background:white;\" frameborder=\"0\" scrolling=\"no\"></iframe>\n</div>",
    "supporting": [
      "post-Scaling-variables-in-R_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}